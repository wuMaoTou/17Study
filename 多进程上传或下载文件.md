#Android多线程上传/下载文件
**背景:**用于改进项目当前多图片上传工具

##线程池分类
> **1.CachedThreadPool:**
> 可缓存线程池,如果线程池线程数量超过处理需要,科灵活回收空闲的线程,如无可回收,则新建线程.线程池为无限大,当执行第二个任务时第一个任务已经完成,会复用执行死一个任务的线程,而不用每次新建线程
> 
> **2.FixedThreadPool:**
> 定长线程池,可控制线程最大并发数,超出线程会再队列钟等待.线程池初始化是固定大小,每次提交任务就创建一个线程,直到线程数量达到线程池最大值.线程池的大小达到最大值后保持不变,对于超出的线程会在LinkedBlockingQueue队列中等待
> 
> **3.ScheduledThreadPool:**
> 定长线程池,支持定时及周期性执行任务,ScheduledExecutorService比Timer更安全,功能更强大
> 
> **4.SingleThreadExecutor:**
> 单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务按照指定顺序(FIFO,LIFO优先级)执行

这里我们优先考虑使用FixedThreadPool,一般线程对应着设备的cpu的线程数,当设置线程数为cpu线程数时效率是最高的,实际的应用中还是根据需求来做最优的线程数控制


##线程池的主要方法
> **shutdown():**启动一次顺序关闭,执行之前提交的任务,不接受新任务,如果已经关闭,则无其他作用
> 
> **shutdownNow():**试图停止所有正在执行的活动任务,暂停处理正在等待的任务,并返回等待执行的任务列表.无法保证能够停止正在处理的活动执行任务,但是会尽力尝试.例如,通过Thread.interrupt()来取消典型的实现,所以任何任务无法响应中断都可能永远无法终止.
> 
> **submit():**提交Runable任务用于执行,并返回一个表示改任务的Future.Future的get方法在成功后将返回null

1. 当所有任务完成后,线程池必须调用shutdown来关闭线程池释放资源,否则线程池一直在等待新任务的加入.
2.  当需要中断所有任务时,可以调用shutdownNow来强制中断正在执行的线程,等待执行的线程会返回,不会被中断.

##CountDownLatch
> 一个同步辅助类,再完成一组正在其他线程中执行的操作之前,他允许一个或多个线程一直等待.给定计数初始化CountDownLatch,调用countDown()方法,所以在当前计数达到0之前,await方法会一直受阻.之后,会释放所有等待的线程,await的所有后续调用都将立即返回.这种现象只出现一次,计数不会被重置

根据上面的定义,CountDownLatch在初始化时传入一个整型数,设置执行任务的数量.CountDownLatch的计数值无法重置,只能通过构造函数创建新的对象.我们可以分成两种线程:一种是工作线程,当执行完毕后调用countDown()使计数器减1,表示执行完毕;一种是监听线程,调用await()方法阻塞,知道CountDownLatch的计数为0才开始执行,这时就可以通过异步通知主线程所有任务完成.

